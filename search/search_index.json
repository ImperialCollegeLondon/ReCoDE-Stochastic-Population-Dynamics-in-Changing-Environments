{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":""},{"location":"#cell-population-dynamics-in-continuous-time-domain","title":"Cell Population Dynamics in Continuous Time Domain","text":""},{"location":"#description","title":"Description","text":"<p>This project explores the mathematical modeling of cell population dynamics using the McKendrick\u2013Von Foerster equation. The focus is on understanding the time-independent case where cell division and death rates depend on the cell's age.</p>"},{"location":"#learning-outcomes","title":"Learning Outcomes","text":"<ul> <li>Understand the McKendrick\u2013Von Foerster equation for population dynamics.</li> <li>Apply separation of variables to solve partial differential equations.</li> <li>Derive and interpret the Euler-Lotka equation for population growth rates.</li> </ul>"},{"location":"#requirements","title":"Requirements","text":""},{"location":"#academic","title":"Academic","text":"<ul> <li>Basic knowledge of differential equations and mathematical modeling.</li> <li>Familiarity with population dynamics concepts.</li> </ul>"},{"location":"#system","title":"System","text":"<ul> <li>Python 3.11 or newer</li> <li>MkDocs for documentation generation</li> <li>Miniconda (recommended for managing dependencies)</li> </ul>"},{"location":"#getting-started","title":"Getting Started","text":"<ol> <li>Clone the repository and navigate to the project directory.</li> <li>Set up a virtual environment and install the required dependencies:    <pre><code>conda create --name cell-population-dynamics python=3.11\nconda activate cell-population-dynamics\npip install -r requirements.txt\n</code></pre></li> </ol>"},{"location":"#project-structure","title":"Project Structure","text":"<pre><code>.\n\u251c\u2500\u2500 docs\n\u251c\u2500\u2500 notebooks\n\u251c\u2500\u2500 src\n\u2502   \u251c\u2500\u2500 __init__.py\n|   \u251c\u2500\u2500 cells_manager.py   # Cell population manager\n|   \u251c\u2500\u2500 plots.py           # Plotting functions\n|   \u251c\u2500\u2500 run.py             # Main script to run the simulation\n|   \u251c\u2500\u2500 simulation.py      # Core simulation logic\n\u2502   \u2514\u2500\u2500 utils.py           # Utility functions\n\u251c\u2500\u2500 mkdocs.yml\n\u251c\u2500\u2500 requirements.txt\n\u2514\u2500\u2500 README.md\n</code></pre>"},{"location":"#mkdocs-documentation","title":"MkDocs Documentation","text":"<p>To generate local documentation, run the following command:</p> <pre><code>mkdocs serve\n</code></pre>"},{"location":"#license","title":"License","text":"<p>This project is licensed under the BSD-3-Clause license</p>"},{"location":"01-introduction/","title":"Introduction","text":"<p>The dynamics of cell populations are fundamental to understanding various biological processes, from the spread of bacterial infections to the growth of cancerous tumors. At the intersection of biophysics and mathematical biology, studying these dynamics provides insights into how populations of cells grow, divide, and die under different environmental conditions. This knowledge has profound implications for medicine, biotechnology, and ecology. </p> <p>In biological systems, cells constantly interact with their environment, which influences their division and death rates. For example, bacteria exposed to antibiotics experience changes in their proliferation and survival rates, and cancer cells undergoing treatment are similarly affected by the drugs they encounter. Both scenarios exemplify how external factors, whether steady or fluctuating, can shape the fate of a population. To effectively intervene\u2014whether to reduce harmful cell populations or enhance beneficial ones\u2014we must understand how these environmental factors influence growth and extinction.</p>"},{"location":"01-introduction/#why-study-population-dynamics","title":"Why Study Population Dynamics?","text":"<p>The biophysics of population dynamics involves understanding how individual cell behaviors contribute to overall population trends. Two key processes\u2014cell division and cell death\u2014determine whether a population grows, stabilizes, or declines. In real-world scenarios, these processes are influenced by the environment in time-dependent and time-independent ways. Examples include:</p> <ol> <li> <p>Antibiotics and Bacterial Growth: Antibiotic levels in the body vary over time, creating a fluctuating environment that affects bacterial division and death rates. Understanding these effects can help optimize dosage and timing to suppress bacterial populations effectively.</p> </li> <li> <p>Cancer Treatments: Cancer cells often exhibit varying sensitivity to treatment. Drugs may temporarily reduce division rates or increase death rates, but their effectiveness can diminish over time. Studying how these fluctuations affect population dynamics can inform strategies to maximize therapeutic outcomes.</p> </li> <li> <p>Biotechnological Applications: In synthetic biology and tissue engineering, controlling cell population growth is critical. Whether growing cell cultures or managing engineered organisms, it is essential to predict and guide population behaviors under varying conditions.</p> </li> </ol>"},{"location":"01-introduction/#objectives-of-this-exemplar","title":"Objectives of This Exemplar","text":"<p>This exemplar focuses on simulating and analyzing cell population dynamics under two key scenarios: </p> <ol> <li> <p>Time-Independent Environment: In this scenario, the division rate \\gamma(\\tau) and death rate \\delta(\\tau) depend only on the age of cells but remain constant over time. We study the population's growth rate and the probability of extinction using mathematical techniques like separation of variables and numerical simulations.</p> </li> <li> <p>Time-Dependent Environment: Here, division and death rates fluctuate over time, modeling realistic environments where external factors like drug concentration or nutrient availability change periodically. We examine the relationship between growth rate and the period of these fluctuations, comparing the results to time-independent cases.</p> </li> </ol> <p>Through these simulations, we aim to address critical questions in cell population biophysics: - How do time-dependent environments influence the growth or extinction of a population compared to time-independent ones? - What are the long-term growth rates under different environmental conditions? - Which treatment strategies are most effective for controlling harmful cell populations, such as bacteria or cancer cells?</p>"},{"location":"02-math-background/","title":"Mathematical Theory","text":"<p>To model the stochastic dynamics of cell populations under time-dependent division and death rates, we require a rigorous mathematical framework. Here, we address the challenges and methods used to simulate such systems in continuous time.</p>"},{"location":"02-math-background/#stochastic-nature-of-events","title":"Stochastic Nature of Events","text":"<p>For each cell, it is stochastic whether it will divide or die, and the time at which it meets this fate is also stochastic. The division and death processes are modeled as independent Poisson processes with time-varying rates: - Division rate: \\gamma(\\tau, t), dependent on cell age \\tau and environment time t. - Death rate: \\delta(\\tau, t), also dependent on \\tau and t.</p> <p>For a cell born at time t_i, the probability density of the next division or death event at time t is given by:  where \\tau = t - t_i. The actual event (division or death) is determined by comparing \\gamma(\\tau, t) and \\delta(\\tau, t) at the sampled event time. Whichever occurs sooner will determine the fate of the cell.</p>"},{"location":"02-math-background/#challenges-in-time-dependent-environments","title":"Challenges in Time-Dependent Environments","text":"<ol> <li>Non-Constant Intensity Functions: In time-dependent environments, rates \\gamma(\\tau, t) and \\delta(\\tau, t) vary continuously, necessitating dynamic sampling algorithms.</li> <li>Continuous-Time Events: Unlike discrete simulations, events occur at irregular intervals sampled from exponential distributions with non-uniform rates. This means the epoch-based iterated simulation using the discrete times approach is not directly applicable.</li> <li>Event Selection: For each cell, the next event is determined by comparing division and death times, adding complexity to the simulation.</li> </ol>"},{"location":"02-math-background/#thinning-method-for-time-dependent-rates","title":"Thinning Method for Time-Dependent Rates","text":"<p>To handle non-constant rates, we employ the thinning method, which generates event times for inhomogeneous Poisson processes.</p> <ol> <li> <p>Identify Maximum Rate:    Compute \\gamma_{\\max}, the upper bound of \\gamma(\\tau, t) over the relevant time interval [t_i, T]:     </p> </li> <li> <p>Sample Candidate Event Time:    Propose a time \\tau^* sampled from an exponential distribution with rate \\gamma_{\\max}:     </p> </li> <li> <p>Acceptance-Rejection Step:    Accept \\tau^* as the next event time if:        Otherwise, repeat the sampling process.</p> </li> <li> <p>Determine Event Type:    At \\tau^*, compare \\gamma(\\tau^*, t_i + \\tau^*) and \\delta(\\tau^*, t_i + \\tau^*) to decide whether the event is a division or a death.</p> </li> </ol>"},{"location":"02-math-background/#incorporating-death-rates","title":"Incorporating Death Rates","text":"<p>To include death rates, the algorithm samples both the division and death times for each cell: - Compute the time until the next event, \\tau_{\\text{event}} = \\min(\\tau_{\\text{division}}, \\tau_{\\text{death}}). - If \\tau_{\\text{event}} = \\tau_{\\text{division}}, the cell divides; otherwise, it dies.</p> <p>Newly created cells are treated as independent entities, with their division and death times sampled afresh.</p>"},{"location":"02-math-background/#simulation-goals","title":"Simulation Goals","text":"<p>The simulation evaluates the population growth rate k and the effective initial population size parameter b across thousands of events. By comparing time-dependent and time-independent environments, we study the impact of oscillatory rates and their periods on long-term population behavior. </p> <p>By simulating each cell, we can determine how a population of cells evolves over time, including whether and how fast the population grows or dies out. By repeating this simulation for many processes we can obtain average values which describe the system in terms of its average behaviour and other properties.</p>"},{"location":"03-numerical-method/","title":"Numerical method","text":""},{"location":"03-numerical-method/#overview","title":"Overview","text":"<p>This code simulates a stochastic birth-death process, where individual cells undergo division over time. The division process follows a probabilistic model, with division times sampled from a gamma distribution. The process includes the generation of new cells (birth) and the deactivation of parent cells post-division (death). The primary objective is to study the dynamics of this process, specifically the relationship between division times and the logarithm of cell count.</p>"},{"location":"03-numerical-method/#mathematical-framework","title":"Mathematical Framework","text":""},{"location":"03-numerical-method/#1-cell-representation","title":"1. Cell Representation","text":"<p>Each cell is represented as a dataclass:</p> <p>where:</p> <ul> <li><code>id</code>: Unique identifier for the cell.</li> <li><code>born_time</code>: The time   at which the cell was created (birth time).</li> <li><code>life_time</code>: The time at which the cell will die.</li> <li><code>division_time</code>: The time  at which the cell is expected to divide.</li> <li><code>is_alive</code>: Boolean indicating whether the cell is active (<code>True</code>) or inactive (<code>False</code>).</li> <li><code>will_divide</code>: Boolean indicating if the cell will divide before it dies (<code>True</code>) or not (<code>False</code>).</li> </ul>"},{"location":"03-numerical-method/#2-division-time-sampling","title":"2. Division Time Sampling","text":"<p>The division time for a new cell is sampled from a gamma distribution:  where:</p> <ul> <li> : Shape parameter.</li> <li> : Scale parameter.</li> </ul> <p>The expected value and variance of the gamma distribution are:  </p>"},{"location":"03-numerical-method/#3-simulation-algorithm","title":"3. Simulation Algorithm","text":"<p>The process begins with a single cell at . At each step: 1. Identify the cell with the earliest division time . 2. Divide the selected cell, creating two daughter cells. 3. Repeat the process for a fixed number of iterations.</p>"},{"location":"03-numerical-method/#4-analysis-of-division-times","title":"4. Analysis of Division Times","text":"<p>The simulation outputs the division times of all cells. For analysis:</p> <ul> <li>Division times are sorted in ascending order:</li> </ul> <p> </p> <ul> <li>A linear regression is performed on the relationship between  (logarithm of rank) and .</li> </ul>"},{"location":"03-numerical-method/#regression-model","title":"Regression Model:","text":"t_{\\text{div}} = \\beta \\log(N-1) + \\alpha <p>where:</p> <ul> <li>\\beta: Slope (regression coefficient).</li> <li>\\alpha: Intercept.</li> </ul>"},{"location":"03-numerical-method/#5-monte-carlo-simulation","title":"5. Monte Carlo Simulation","text":"<p>To study variability in the regression parameters:</p> <ul> <li>The simulation is repeated  times.</li> <li>For each run, the regression coefficients \\beta and intercepts \\alpha are stored.</li> </ul>"},{"location":"03-numerical-method/#6-statistical-output","title":"6. Statistical Output","text":"<p>The distributions of  and  are analyzed:</p> <ul> <li>Histograms of  illustrate the variability in the growth rate of division times.</li> <li>A compressed NumPy file stores the coefficients and intercepts for further analysis.</li> </ul>"},{"location":"03-numerical-method/#mathematical-results","title":"Mathematical Results","text":""},{"location":"03-numerical-method/#key-observations","title":"Key Observations:","text":"<ol> <li>The stochastic birth-death process results in an exponentially increasing number of cells over time.</li> <li>The relationship between division times t_{\\text{div}} and logarithm of rank \\log(N-1) is approximately linear for sufficiently large N, as suggested by the regression model.</li> </ol>"},{"location":"03-numerical-method/#regression-interpretation","title":"Regression Interpretation:","text":"<p>The slope \\beta reflects the rate of increase in division times as the population grows, while the intercept  represents the baseline division time.</p> <p>Analysis Method Overview We analyze the stochastic birth-death process using linear regression to study the relationship between division times and logarithmic cell count. The regression model is given by:</p>  t_{\\mathrm{div}}=\\beta \\log (N-1)+\\alpha  <p>where:</p> <ul> <li>t_{\\text {div }} is the division time,</li> <li>N is the total number of cells,</li> <li>\\beta (slope) represents the growth rate k,</li> <li>\\alpha (intercept) represents the effective initial population size parameter b.</li> </ul> <p>We estimate \\beta and \\alpha using least squares regression, fitting the observed division times to the logarithm of cell count.</p>"},{"location":"03-numerical-method/#conclusion","title":"Conclusion","text":"<p>This simulation provides a detailed mathematical model for understanding cell division dynamics in a stochastic setting. The use of gamma distributions for division times introduces variability, mimicking real biological systems. By analyzing the relationship between division times and cell count, the model offers insights into the temporal evolution of the system.</p>"},{"location":"04-coding/","title":"Coding techniques and design patterns","text":""},{"location":"04-coding/#design-patterns-used-in-the-simulation","title":"Design Patterns Used in the Simulation","text":"<p>The simulation code for cell population dynamics employs several design patterns to enhance modularity, extensibility, and maintainability. Here are the key design patterns used in the implementation:</p>"},{"location":"04-coding/#1-factory-method-pattern-cell-initialization","title":"1. Factory Method Pattern (Cell Initialization)","text":"<ul> <li>The <code>Cell</code> class contains the methods <code>init_immortal_cell</code>, <code>init_dividable_cell</code> and <code>deactivate_cell</code> which create instances of the <code>Cell</code> class with some aspects pre-defined as a part of the method. </li> <li>This sort of method is known as a factory method, and makes the creation of instances of the <code>Cell</code> class more convenient and easier to understand and ensures consistent initialization logic.</li> </ul>"},{"location":"04-coding/#2-strategy-pattern-customizable-functions-for-lifetime-and-division","title":"2. Strategy Pattern (Customizable Functions for Lifetime and Division)","text":"<ul> <li>The simulation class takes <code>division_func</code> and <code>lifetime_func</code> as parameters.</li> <li>This allows the user to plug in different strategies for computing division and lifetime, making the simulation flexible without modifying core logic.</li> <li>Implemented using lambda functions of the distribution which do not depend on discretization.</li> </ul>"},{"location":"04-coding/#3-simulation-loop-event-driven-design","title":"3. Simulation Loop (Event-Driven Design)","text":"<ul> <li>The run method repeatedly processes the next event based on <code>find_next_event()</code>.</li> <li>Events are dynamically determined rather than using fixed time steps, making the simulation in the continuous time domain without any discretization.</li> <li>The simulation is free of any time discretization issues that arise in epoch-based simulations.</li> </ul>"},{"location":"04-coding/#4-state-pattern-cell-lifecycle","title":"4. State Pattern (Cell Lifecycle)","text":"<ul> <li>The Cell class has attributes like <code>is_alive</code> and <code>will_divide</code>, which dictate its behavior.</li> <li>The <code>deactivate_cell</code> function transitions a cell's state from alive to inactive.</li> </ul>"},{"location":"04-coding/#5-observer-pattern-logging-events","title":"5. Observer Pattern (Logging Events)","text":"<ul> <li>The <code>log_event</code> method records key events (division and death) during the simulation.</li> <li>This allows external components to observe and analyze the simulation history.</li> </ul>"},{"location":"04-coding/#coding-techniques-for-efficiency-and-readability","title":"Coding Techniques for Efficiency and Readability","text":""},{"location":"04-coding/#lambda-functions","title":"Lambda Functions","text":"<p>The use of lambda functions allows for concise and readable definitions of functions, especially when defining custom probability distributions for division and lifetime. This is particularly useful since no discrete of probability distributions are used in the simulation.</p> <pre><code>division_func = lambda x: np.random.gamma(5, 1, x)\nlifetime_func = lambda x: np.random.exponential(1, x)\n</code></pre> <p>This approach simplifies the code and makes it easier to understand the logic behind the simulation.</p>"},{"location":"a1-math-proof/","title":"A1 math proof","text":""},{"location":"a1-math-proof/#appendix-1-mathematical-analysis-for-the-time-independent-case","title":"Appendix 1 - Mathematical Analysis for the Time-Independent Case","text":""},{"location":"a1-math-proof/#problem-definition","title":"Problem Definition","text":"<p>We consider a population of cells where each cell can either divide at a rate \\gamma(\\tau) or die at a rate  \\delta(\\tau), both dependent only on the cell's age \\tau. In this scenario, the McKendrick\u2013Von Foerster  equation governing the population dynamics is:</p>  \\begin{aligned} \\left(\\partial_t + \\partial_\\tau\\right) n(\\tau, t) &amp;= -\\left(\\gamma(\\tau) + \\delta(\\tau)\\right) n(\\tau, t), \\\\ n(0, t) &amp;= 2 \\int_0^\\infty \\gamma(\\tau) n(\\tau, t) \\, d\\tau. \\end{aligned}"},{"location":"a1-math-proof/#key-components","title":"Key Components:","text":"<ol> <li>Cell Division (\\gamma(\\tau)): A cell can divide at an age-dependent rate.</li> <li>Cell Death (\\delta(\\tau)): A cell can die before dividing, also at an age-dependent rate.</li> <li>Birth Condition: Division creates two new cells of age zero, forming the boundary condition at n(0, t).</li> </ol> <p>Our goal is to determine the population dynamics n(\\tau, t), particularly the asymptotic growth rate \\lambda,  under the assumption of time-independent division and death rates.</p>"},{"location":"a1-math-proof/#separation-of-variables","title":"Separation of Variables","text":"<p>To solve the PDE, we assume the solution can be expressed as:  where: - N_\\lambda(t): Time-dependent population size associated with eigenvalue \\lambda. - \\pi_\\lambda(\\tau): Age distribution for the eigenvalue \\lambda.</p> <p>Substituting into the PDE and separating variables, we obtain:  </p> <p>From this, we solve the time-dependent and age-dependent parts separately:  </p> <p>The eigenvalue \\lambda determines the growth or decay rate of the population. It is obtained from the boundary condition:  </p> <p>Substituting the expression for n(\\tau, t), we arrive at:  </p>"},{"location":"a1-math-proof/#deriving-the-euler-lotka-equation","title":"Deriving the Euler-Lotka Equation","text":"<p>To further simplify, we define the division probability density function \\phi(\\tau) and the death survival function \\varphi(\\tau) as follows: 1. Division rate as a hazard function:     2. Death survival function:     </p> <p>Combining these, the boundary condition reduces to the Euler-Lotka equation:  where: - e^{-\\lambda \\tau}: Discount factor due to exponential population growth. - \\phi(\\tau): Probability density of division at age \\tau. - \\varphi(\\tau): Probability of survival from death up to age \\tau.</p> <p>The equation can be solved numerically or analytically for \\lambda, depending on the specific forms of \\gamma(\\tau) and \\delta(\\tau).</p>"},{"location":"a1-math-proof/#special-cases","title":"Special Cases","text":""},{"location":"a1-math-proof/#1-immortal-cells-deltatau-0deltatau-0","title":"1. Immortal Cells (\\delta(\\tau) = 0)","text":"<p>If cells do not die, the division rate is constant, \\gamma(\\tau) = R. The probability density function of division is:  </p> <p>The Euler-Lotka equation becomes:  Evaluating the integral:  Solving for \\lambda:  This result shows that the population growth rate equals the division rate when no cells die.</p>"},{"location":"a1-math-proof/#2-normal-cells-deltatau-ddeltatau-d","title":"2. Normal Cells (\\delta(\\tau) = D)","text":"<p>If cells die at a constant rate D, the death survival function becomes:  </p> <p>The Euler-Lotka equation becomes:  Evaluating the integral:  Solving for \\lambda:  </p>"},{"location":"a1-math-proof/#interpretation","title":"Interpretation","text":"<ol> <li>When R &gt; D, the population grows at a rate \\lambda = R - D.</li> <li>When R = D, the population size remains constant (\\lambda = 0).</li> <li>When R &lt; D, the population declines (\\lambda &lt; 0).</li> </ol>"},{"location":"a2-reference/","title":"Appendix 2 - References","text":"<p>[1] Thomas Robert Malthus, Donald Winch, and Patricia James. Malthus:\u2019An Essay on the Prin ciple of Population\u2019. Cambridge university press, 1992</p> <p>[2] Hisashi Inaba. Age-structured population dynamics in demography and epidemiology. Springer,  2017. URL: https://doi.org/10.1007/978-4-431-56469-0.</p> <p>[3] Peter Turchin. Complex population dynamics. In Complex Population Dynamics. Princeton  university press, 2013.</p> <p>[4] Debasish. The malthusian theory of population (criticism). economics discussion online net,  unkonwn.</p>"},{"location":"usage_example/","title":"Simulation Parameters and Functions","text":"In\u00a0[1]: Copied! <pre>from src.run import single_run, multi_run, extract_regression_results, set_seed\nfrom src.plots import plot_population_dynamics, log_population_regression, compare_multi_runs, plot_distribution\nfrom src.utils import (\n    exponential_lifetime, uniform_sample, gamma_sample,\n    cos_sample, fixed_lifetime\n)\n</pre> from src.run import single_run, multi_run, extract_regression_results, set_seed from src.plots import plot_population_dynamics, log_population_regression, compare_multi_runs, plot_distribution from src.utils import (     exponential_lifetime, uniform_sample, gamma_sample,     cos_sample, fixed_lifetime ) In\u00a0[3]: Copied! <pre>division_functions = {\n    \"exponential\": lambda x: exponential_lifetime(x, mean_lifetime=5.0),\n    \"uniform\": lambda x: uniform_sample(x, low=1.0, high=10.0),\n    \"gamma\": lambda x: gamma_sample(x, shape=2.0, scale=5.0),\n    \"cosine\": lambda x: cos_sample(x),\n    \"fixed\": lambda x: fixed_lifetime(x, lifetime_constant=10.0),\n}\n\nlifetime_functions = {\n    \"exponential\": lambda x: exponential_lifetime(x, mean_lifetime=15.0),\n    \"uniform\": lambda x: uniform_sample(x, low=10.0, high=20.0),\n    \"gamma\": lambda x: gamma_sample(x, shape=2.0, scale=15.0),\n    \"cosine\": lambda x: cos_sample(x),\n    \"fixed\": lambda x: fixed_lifetime(x, lifetime_constant=20.0),\n}\n\ndivision_func = division_functions['exponential']\nlifetime_func = lifetime_functions['exponential']\n</pre> division_functions = {     \"exponential\": lambda x: exponential_lifetime(x, mean_lifetime=5.0),     \"uniform\": lambda x: uniform_sample(x, low=1.0, high=10.0),     \"gamma\": lambda x: gamma_sample(x, shape=2.0, scale=5.0),     \"cosine\": lambda x: cos_sample(x),     \"fixed\": lambda x: fixed_lifetime(x, lifetime_constant=10.0), }  lifetime_functions = {     \"exponential\": lambda x: exponential_lifetime(x, mean_lifetime=15.0),     \"uniform\": lambda x: uniform_sample(x, low=10.0, high=20.0),     \"gamma\": lambda x: gamma_sample(x, shape=2.0, scale=15.0),     \"cosine\": lambda x: cos_sample(x),     \"fixed\": lambda x: fixed_lifetime(x, lifetime_constant=20.0), }  division_func = division_functions['exponential'] lifetime_func = lifetime_functions['exponential'] In\u00a0[4]: Copied! <pre>set_seed(41)\n\n# Run a single simulation\nsim = single_run(epoch=400, division_func=division_func, lifetime_func=lifetime_func)\n\n# Visualize single simulation\nplot_population_dynamics(sim)\nlog_population_regression(sim)\n</pre> set_seed(41)  # Run a single simulation sim = single_run(epoch=400, division_func=division_func, lifetime_func=lifetime_func)  # Visualize single simulation plot_population_dynamics(sim) log_population_regression(sim) <pre>&lt;Figure size 1600x900 with 0 Axes&gt;</pre> In\u00a0[9]: Copied! <pre>set_seed(50)\n\n# Define division and lifetime functions\ndivision_func = lambda x: exponential_lifetime(x, mean_lifetime=5.0)\nlifetime_func = lambda x: exponential_lifetime(x, mean_lifetime=15.0)\n\n# Run multiple simulations\nsims = multi_run(epoch=50, num_runs=10, division_func=division_func, lifetime_func=lifetime_func)\n\n# Compare results from multiple runs\ncompare_multi_runs(sims)\n</pre> set_seed(50)  # Define division and lifetime functions division_func = lambda x: exponential_lifetime(x, mean_lifetime=5.0) lifetime_func = lambda x: exponential_lifetime(x, mean_lifetime=15.0)  # Run multiple simulations sims = multi_run(epoch=50, num_runs=10, division_func=division_func, lifetime_func=lifetime_func)  # Compare results from multiple runs compare_multi_runs(sims) In\u00a0[15]: Copied! <pre>set_seed(50)\n\n# Define division and lifetime functions\ndivision_func = lambda x: exponential_lifetime(x, mean_lifetime=5.0)\nlifetime_func = lambda x: exponential_lifetime(x, mean_lifetime=15.0)\n\n# Run multiple simulations\nsims = multi_run(epoch=200, num_runs=2000, division_func=division_func, lifetime_func=lifetime_func)\n\ndata_independent = extract_regression_results(sims)\n\n# Plot the distributions for coefficients\nplot_distribution(data_independent, column='coef', binwidth=0.005, color='coral',\n                  xlabel='Coefficient', ylabel='Frequency',\n                  title='Distribution of Regression Coefficients')\n\n# Plot the distributions for intercepts\nplot_distribution(data_independent, column='intercept', binwidth=0.1, color='teal',\n                  xlabel='Intercept', ylabel='Frequency',\n                  title='Distribution of Regression Intercepts')\n</pre> set_seed(50)  # Define division and lifetime functions division_func = lambda x: exponential_lifetime(x, mean_lifetime=5.0) lifetime_func = lambda x: exponential_lifetime(x, mean_lifetime=15.0)  # Run multiple simulations sims = multi_run(epoch=200, num_runs=2000, division_func=division_func, lifetime_func=lifetime_func)  data_independent = extract_regression_results(sims)  # Plot the distributions for coefficients plot_distribution(data_independent, column='coef', binwidth=0.005, color='coral',                   xlabel='Coefficient', ylabel='Frequency',                   title='Distribution of Regression Coefficients')  # Plot the distributions for intercepts plot_distribution(data_independent, column='intercept', binwidth=0.1, color='teal',                   xlabel='Intercept', ylabel='Frequency',                   title='Distribution of Regression Intercepts') In\u00a0[\u00a0]: Copied! <pre>\n</pre>"},{"location":"usage_example/#simulation-parameters-and-functions","title":"Simulation Parameters and Functions\u00b6","text":"<p>Select the division and lifetime functions to use for the simulation. The following functions are available:</p> <ul> <li>Exponential</li> <li>Uniform</li> <li>Gamma</li> <li>Cosine</li> <li>Fixed</li> </ul> <p>Or you can define your own lambda function to use for division and lifetime.</p>"},{"location":"usage_example/#single-run","title":"Single Run\u00b6","text":"<p>The following code snippet demonstrates how to run a single simulation and visualize the results.</p> <p>We use log-linear regression to fit the population dynamics and plot the regression results.</p>"},{"location":"usage_example/#analysis-of-single-run","title":"Analysis of Single Run\u00b6","text":"<p>The following code snippet demonstrates how to analyze the results of a single simulation. We can see that the population dynamics follow a log-linear trend, with the population growing exponentially in the long run.</p>"},{"location":"usage_example/#multiple-runs","title":"Multiple Runs\u00b6","text":"<p>The following code snippet demonstrates how to run multiple simulations and compare the results.</p> <p>We see that the trajectories are different for each run, some die out quickly, while others grow exponentially.</p>"},{"location":"usage_example/#analysis-of-multiple-runs","title":"Analysis of Multiple Runs\u00b6","text":"<p>The following code snippet demonstrates how to analyze the results of multiple simulations. One can observe that the population dynamics vary significantly across different runs, with some populations growing rapidly and others dying out quickly. For different exponential-like trajectories in the long run, the growth rates are different.</p>"},{"location":"usage_example/#regression-analysis","title":"Regression Analysis\u00b6","text":"<p>The following code snippet demonstrates how to perform regression analysis on the population dynamics.</p> <p>We extract the regression results from multiple runs and visualize the distributions of regression coefficients and intercepts.</p>"},{"location":"usage_example/#regression-analysis","title":"Regression Analysis\u00b6","text":"<p>The following code snippet demonstrates how to analyze the regression results from multiple simulations.</p> <p>We extract the regression coefficients and intercepts from the population dynamics and visualize their distributions.</p> <p>From the distributions, we can observe that the regression coefficients and intercepts are closed to normally distributed around the true values.</p>"}]}